package main

import (
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
)

var (
	// Output file path for the generated Go source file.
	output string

	// Template for the autogenerated Go file containing the list of schemes.
	schemesTmpl = template.Must(template.New("schemes").Parse(`// This file is autogenerated by the schemes generator. Please do not edit manually.
package schemes

// Official is a sorted list of all IANA-assigned URL schemes.
// This list is periodically fetched from the IANA registry to ensure it is up-to-date.
// The data is retrieved from:
//   - https://www.iana.org/assignments/uri-schemes/uri-schemes-1.csv
//
// URL schemes, also known as URI schemes, are the prefixes used to define how a resource should be accessed.
// Common examples include "http", "https", "ftp", and many others.
//
// This list includes the full set of schemes officially assigned by the Internet Assigned Numbers Authority (IANA).
// It is used to verify or process URL schemes in various applications.
var Official = []string{
{{- range $scheme := .Schemes}}
	"{{$scheme}}",
{{- end}}
}
`))
)

func init() {
	// Define the command-line flag for output file path
	flag.StringVar(&output, "output", "", "Specify the output file path for the generated Go source file.")

	// Custom usage message for the command-line flag
	flag.Usage = func() {
		h := "USAGE:\n"
		h += "  schemes [OPTIONS]\n"

		h += "\nOPTIONS:\n"
		h += " -output string    Specify the output file path for the generated Go source file.\n"

		fmt.Fprintln(os.Stderr, h)
	}

	// Parse command-line flags
	flag.Parse()
}

func main() {
	// Ensure that an output file path is specified
	if output == "" {
		log.Fatalln("Output file path is required. Use -output to specify the output file path.")
	}

	log.Printf("Generating %s...\n", output)

	// Fetch and generate the list of URI schemes
	schemes, err := fetchSchemesList()
	if err != nil {
		log.Fatalf("Failed to fetch schemes: %v\n", err)
	}

	// Write the schemes to the output file
	if err := writeSchemesToFile(schemes, output); err != nil {
		log.Fatalf("Failed to write schemes to file: %v\n", err)
	}

	log.Println("Schemes file generated successfully.")
}

// fetchSchemesList fetches the list of URI schemes from the IANA CSV file
// and returns a slice of valid scheme names.
func fetchSchemesList() (schemes []string, err error) {
	// Perform HTTP GET request to fetch the CSV file
	schemesSourcesURL := "https://www.iana.org/assignments/uri-schemes/uri-schemes-1.csv"

	var res *http.Response

	res, err = http.Get(schemesSourcesURL)
	if err != nil {
		err = fmt.Errorf("failed to fetch the schemes CSV: %w", err)

		return
	}

	defer res.Body.Close()

	// Create a new CSV reader for parsing the response body
	reader := csv.NewReader(res.Body)

	// Skip the CSV header row
	if _, err = reader.Read(); err != nil {
		err = fmt.Errorf("failed to read CSV header: %w", err)

		return
	}

	for {
		var record []string

		record, err = reader.Read()

		// End of file reached
		if errors.Is(err, io.EOF) {
			err = nil

			break
		}

		if err != nil {
			err = fmt.Errorf("error reading CSV row: %w", err)

			return
		}

		// Skip rows marked as OBSOLETE
		if strings.Contains(record[0], "OBSOLETE") {
			continue // skip obsolete schemes; note the scheme column is abused
		}

		// Append valid scheme to the list
		schemes = append(schemes, record[0])
	}

	return
}

// writeSchemesToFile writes the generated list of URI schemes to the specified file
// using a Go source file template.
func writeSchemesToFile(schemes []string, output string) (err error) {
	// Create the output file
	file, err := os.Create(output)
	if err != nil {
		err = fmt.Errorf("failed to create output file: %w", err)

		return
	}

	defer file.Close()

	// Execute the template and write to the output file
	data := struct {
		Schemes []string
	}{
		Schemes: schemes,
	}

	if err := schemesTmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return
}

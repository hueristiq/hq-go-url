package main

import (
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
)

var (
	schemesTemplate = template.Must(template.New("schemes").Parse(`// This file is autogenerated by the schemes generator. Please do not edit manually.
package schemes

// Official is a sorted list of all IANA-assigned URL schemes.
// This list is periodically fetched from the IANA registry to ensure it is up-to-date.
// The data is retrieved from:
//   - https://www.iana.org/assignments/uri-schemes/uri-schemes-1.csv
//
// URL schemes, also known as URI schemes, are the prefixes used to define how a resource should be accessed.
// Common examples include "http", "https", "ftp", and many others.
//
// This list includes the full set of schemes officially assigned by the Internet Assigned Numbers Authority (IANA).
// It is used to verify or process URL schemes in various applications.
var Official = []string{
{{- range $scheme := .Schemes}}
	"{{$scheme}}",
{{- end}}
}
`))
	schemesFile string
)

func init() {
	flag.StringVar(&schemesFile, "output", "", "Specify the output file path for the generated Go source file.")

	flag.Usage = func() {
		h := "USAGE:\n"
		h += "  schemes [OPTIONS]\n"

		h += "\nOPTIONS:\n"
		h += " -output string    Specify the output file path for the generated Go source file.\n"

		fmt.Fprintln(os.Stderr, h)
	}

	flag.Parse()
}

func main() {
	if schemesFile == "" {
		log.Fatalln("Output file path is required. Use -output to specify the output file path.")
	}

	log.Printf("Generating %s...\n", schemesFile)

	schemes, err := fetchSchemesList()
	if err != nil {
		log.Fatalf("Failed to fetch schemes: %v\n", err)
	}

	if err := writeSchemesToFile(schemes, schemesFile); err != nil {
		log.Fatalf("Failed to write schemes to file: %v\n", err)
	}

	log.Println("Schemes file generated successfully.")
}

func fetchSchemesList() (schemes []string, err error) {
	schemesSourcesURL := "https://www.iana.org/assignments/uri-schemes/uri-schemes-1.csv"

	var res *http.Response

	res, err = http.Get(schemesSourcesURL)
	if err != nil {
		err = fmt.Errorf("failed to fetch the schemes CSV: %w", err)

		return
	}

	defer res.Body.Close()

	reader := csv.NewReader(res.Body)

	if _, err = reader.Read(); err != nil {
		err = fmt.Errorf("failed to read CSV header: %w", err)

		return
	}

	for {
		var record []string

		record, err = reader.Read()

		if errors.Is(err, io.EOF) {
			err = nil

			break
		}

		if err != nil {
			err = fmt.Errorf("error reading CSV row: %w", err)

			return
		}

		if strings.Contains(record[0], "OBSOLETE") {
			continue
		}

		schemes = append(schemes, record[0])
	}

	return
}

func writeSchemesToFile(schemes []string, schemesFile string) (err error) {
	file, err := os.Create(schemesFile)
	if err != nil {
		err = fmt.Errorf("failed to create output file: %w", err)

		return
	}

	defer file.Close()

	data := struct {
		Schemes []string
	}{
		Schemes: schemes,
	}

	if err := schemesTemplate.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return
}

package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

var (
	TLDsTemplate = template.Must(template.New("schemes").Parse(`// This file is autogenerated by ./gen/main.go. Please do not edit manually.
package tlds

// Official is a sorted list of public top-level domains (TLDs) and effective top-level domains (eTLDs).
//
// TLDs are the highest level in the domain name system, while eTLDs include public suffixes,
// such as country code second-level domains (e.g., "co.uk" or "gov.in"), commonly used for websites.
//
// References:
// - IANA TLDs: https://data.iana.org/TLD/tlds-alpha-by-domain.txt
// - Public Suffix List: https://publicsuffix.org/list/public_suffix_list.dat
// - A-Z TLDs: https://tld-list.com/tlds-from-a-z
// - Wikipedia: https://en.wikipedia.org/wiki/Top-level_domain
var Official = []string{
{{- range $_, $TLD := .TLDs}}
	"{{$TLD}}",
{{- end}}
}
`))
	TLDsFile string
)

func init() {
	flag.StringVar(&TLDsFile, "output", "", "Specify the output file path for the generated Go source file.")

	flag.Usage = func() {
		h := "USAGE:\n"
		h += "  schemes [OPTIONS]\n"

		h += "\nOPTIONS:\n"
		h += " -output string    Specify the output file path for the generated Go source file.\n"

		fmt.Fprintln(os.Stderr, h)
	}

	flag.Parse()
}

func main() {
	if TLDsFile == "" {
		log.Fatalln("Output file path is required. Use -output to specify the output file path.")
	}

	log.Printf("Generating %s...\n", TLDsFile)

	AZTLDs, err := getTLDsFromText()
	if err != nil {
		log.Fatalf("Failed to get TLDs from Text: %v\n", err)
	}

	IANATLDs, err := getTLDsFromIANA()
	if err != nil {
		log.Fatalf("Failed to get TLDs from IANA: %v\n", err)
	}

	eTLDs, err := getEffectiveTLDsFromPublicSuffix()
	if err != nil {
		log.Fatalf("Failed to get effective TLDs from Public Suffix: %v\n", err)
	}

	TLDs := append(AZTLDs, IANATLDs...)
	TLDs = append(TLDs, eTLDs...)

	sort.Strings(TLDs)

	TLDs = removeDuplicates(TLDs)

	if err := writeTLDsToFile(TLDs, TLDsFile); err != nil {
		log.Fatalf("Failed to write schemes to file: %v\n", err)
	}

	log.Println("TLDs file generated successfully.")
}

func getTLDsFromText() (TLDs []string, err error) {
	file, err := os.Open("./tlds/gen/TLDs.txt")
	if err != nil {
		log.Fatalf("failed to open file: %s", err)
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		TLD := scanner.Text()

		if TLD == "" {
			continue
		}

		TLDs = append(TLDs, TLD)
	}

	if err = scanner.Err(); err != nil {
		err = fmt.Errorf("scanner error: %w", err)

		return
	}

	return
}

func getTLDsFromIANA() (TLDs []string, err error) {
	var res *http.Response

	res, err = http.Get("https://data.iana.org/TLD/tlds-alpha-by-domain.txt")
	if err != nil {
		err = fmt.Errorf("failed to fetch IANA TLDs: %w", err)

		return
	}

	defer res.Body.Close()

	re := regexp.MustCompile(`^[^#]+$`)

	scanner := bufio.NewScanner(res.Body)

	for scanner.Scan() {
		line := scanner.Text()

		line = strings.TrimSpace(line)
		line = strings.ToLower(line)

		TLD := re.FindString(line)

		if TLD == "" || strings.HasPrefix(TLD, "xn--") {
			continue
		}

		TLDs = append(TLDs, TLD)
	}

	if err = scanner.Err(); err != nil {
		err = fmt.Errorf("scanner error: %w", err)

		return
	}

	return
}

func getEffectiveTLDsFromPublicSuffix() (eTLDs []string, err error) {
	var res *http.Response

	res, err = http.Get("https://publicsuffix.org/list/effective_tld_names.dat")
	if err != nil {
		err = fmt.Errorf("failed to fetch Public Suffix TLDs: %w", err)

		return
	}

	defer res.Body.Close()

	scanner := bufio.NewScanner(res.Body)

	for scanner.Scan() {
		line := scanner.Text()

		line = strings.TrimSpace(line)

		if strings.HasPrefix(line, "// ===BEGIN PRIVATE DOMAINS") {
			break
		}

		if strings.HasPrefix(line, "//") {
			continue
		}

		TLD := line

		TLD = strings.ReplaceAll(TLD, "*.", "")
		TLD = strings.ReplaceAll(TLD, "!", "")

		if TLD == "" {
			continue
		}

		eTLDs = append(eTLDs, TLD)
	}

	if err = scanner.Err(); err != nil {
		err = fmt.Errorf("scanner error: %w", err)

		return
	}

	return
}

func removeDuplicates[T comparable](slice []T) []T {
	keys := make(map[T]bool)

	var list []T

	for _, entry := range slice {
		if _, exists := keys[entry]; !exists {
			keys[entry] = true

			list = append(list, entry)
		}
	}

	return list
}

func writeTLDsToFile(TLDs []string, TLDsFile string) (err error) {
	file, err := os.Create(TLDsFile)
	if err != nil {
		err = fmt.Errorf("failed to create output file: %w", err)

		return
	}

	defer file.Close()

	data := struct {
		TLDs []string
	}{
		TLDs: TLDs,
	}

	if err := TLDsTemplate.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return
}
